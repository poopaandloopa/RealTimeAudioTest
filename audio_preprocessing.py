import numpy as np
import torch
import torchaudio
from queue import Queue


class MelFeatureExtractor:
    def __init__(self,
                 samples_queue,
                 max_container_size,
                 sample_rate,
                 n_fft,
                 hop_length,
                 win_length,
                 n_mels,
                 mel_step_size=16,
                 fps=25):
        self.samples_queue = samples_queue
        self.max_container_size = max_container_size
        self.sample_rate = sample_rate
        self.n_fft = n_fft
        self.hop_length = hop_length
        self.win_length = win_length
        self.n_mels = n_mels
        self.mel_step_size = mel_step_size
        self.fps = fps

        self.mel_queue = Queue()

    def mel_spectrogram_generator(self):
        """Builds continuous mel spectrogram given a chunk of audio samples"""

        pad_size = self.win_length // 2
        sample_container = np.zeros(pad_size)  # store samples
        mel_container = np.empty((self.n_mels, 0))  # store mel spectrogram
        sample_buffer = np.array([])  # store currently unnecessary samples

        transform = torchaudio.transforms.MelSpectrogram(sample_rate=self.sample_rate, n_fft=self.n_fft,
                                                         win_length=self.win_length, hop_length=self.hop_length,
                                                         n_mels=self.n_mels, center=False)

        mel_chunk_idx = 0
        mel_idx_multiplier = 80 / self.fps

        while True:
            # read the payload from queue generated by RTPReceiver and store in the container
            payload = self.samples_queue.get()

            if len(payload) < 100:
                break

            sample_block = np.frombuffer(payload, dtype=np.int16).astype(np.float32)
            sample_container = np.concatenate([sample_container, sample_buffer, sample_block])

            # read more payloads if necessary
            if len(sample_container) < self.max_container_size:
                continue

            sample_buffer = sample_container[self.max_container_size:]
            sample_container = sample_container[:self.max_container_size]

            sample_container_tensor = torch.Tensor(sample_container)
            mel_block = transform(sample_container_tensor).numpy()
            mel_container = np.hstack([mel_container, mel_block])

            # store last samples to preserve continuity
            sample_container = sample_container[-(self.win_length - self.hop_length):]

            # store enough mel columns to build a spectrogram
            if self.mel_step_size > mel_container.shape[1]:
                continue

            while True:
                start_idx = int(mel_chunk_idx * mel_idx_multiplier)

                if start_idx + self.mel_step_size > mel_container.shape[1]:
                    break

                mel_chunk = mel_container[:, start_idx:start_idx + self.mel_step_size]
                self.mel_queue.put(mel_chunk)
                mel_chunk_idx += 1
